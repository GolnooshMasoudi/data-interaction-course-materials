#+title: Data Interaction Course Materials
#+author: Jens Östlund

This course aims to give you an understanding of back-end development and in it you will learn how to build an HTTP server in node.js and integrating it with a MongoDB database. The course will focus a lot on JavaScript and give you an understanding for how the language works so you will be able to solve issues in your code more readily.

* Setting up your Environment
In order to follow along with this course you will want to have the following installed:

- [[https://nodejs.org/en/][node.js]] v16 or higher
- nom
- An editor with proper JavaScript support (VSCode, Sublime, Vim, Emacs, ...)
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][Git]]

You can check that you have all necessary command line tools by running the following commands in your terminal:

#+begin_src shell
  node --version
  npm --version
  git --version
#+end_src

* Introduction to node.js
In short, node.js is JavaScript for servers and is now one of the most prevalent programming languages in the world. How come it quickly got so popular?

- The same language across the stack (front-end and back-end)
- Simplify the transition to full-stack for front-end developers
- The asynchronous nature of JavaScript makes it great for easily building high performance HTTP servers

In summary: familiarity and performance

Node.JS was created 12 years ago by creating a system interface to Chrome’s [[https://en.wikipedia.org/wiki/V8_(JavaScript_engine)][V8 JavaScript engine]]. That means that Node.JS is running the same version of JavaScript as Chrome and other [[https://en.wikipedia.org/wiki/Chromium_(web_browser)][Chromium]]-based browsers such as Microsoft Edge, Brave etc. Which V8 version Node uses dictates what JavaScript features it supports. If you are curious you can check which exact version of V8 your node.js installation is using by running the following command in a terminal:

#+begin_src shell
  node -p process.versions.v8
#+end_src

** node.js vs the Browser
Moving JavaScript out of the browser and onto the server results in a few important differences:

- There's no browser environment, that is you do not have access to the global ~window~ and ~document~ objects.
- You instead have a global variable ~global~ which refers to the current runtime environment.
- You have access to built-in modules for doing things like reading and writing files and networking etc.
- You have support for two different module systems (/CommonJS/ and /JavaScript modules/).
- You use NPM for managing third party dependencies.

** Hello Node
We are going to play around with node.js a bit. First create a new directory called ~hello-node~ and move into it. Now create a file called =index.js= and write the following piece of code:

#+name: Writing to the terminal
#+begin_src js
  console.log("Hello node! \(>0<)/")
#+end_src

Now you can run your program with the command ~node index.js~ and you should see =Hello node! \(>0<)/= printed to your terminal. We have run JavaScript outside of the browser and successfully printed text, hooray!

A quick aside: naming the main file JavaScript file =index.js= is a convention and has no special meaning to node.js itself apart from it being loaded by default when importing a directory. We will have a look at what this means later, for now you can think of it as being analogous to naming the main page of a website =index.html= to avoid having to specify the full file path in the URL (link).

*** Importing modules (CommonJS vs JavaScript modules)
We can use node.js to play around with files but for that we need to import the built-in file system module ~fs~.

#+name: Writing to files
#+begin_src js
  const fs = require("fs");

  // We write a string to the file text.txt synchronously
  fs.writeFileSync("test.txt", "Here's some text in a file!");

  // And read the contents of it (also here synchronously!)
  const contents = fs.readFileSync("test.txt").toString();

  console.log(`File contents: ${contents}`);
#+end_src

In the above example we are using the default CommonJS style imports (~require~). In the examples in this course we are mainly going to use JavaScript modules (~import~, ~export~). You are free to use whichever style you are most comfortable with. If you want to use the ~import~ syntax you need to edit =package.json= and set the ~type~ property to ~module~ as in the example below. You can generate a =package.json= file by running ~npm init~ in the terminal and just accept all of the suggested default settings.

#+name Add support for JavaScript modules by editing package.json
#+begin_src json
  {
    "name": "hello-node",
    "type": "module",
    ...
  }
#+end_src

Now you can use the ~import~ syntax instead:

#+begin_src js
  import fs from "fs"
#+end_src

*** TODO Creating your own module
* Our First API
** What is an API?
- An API is a set of exposed methods for interacting with a program or package.
- When you write a JavaScript module and export functions to interact with it you are designing an API.
- When you are interacting with a third-party package, for example =express=, you are using its API.
- Designing an API allows you to create a layer of abstraction which hides implementation details and simplifies using your service or package.

Often when we say API we actually mean an HTTP API to be specific, that is an API which is used over the internet using HTTP.

** Creating our API
Express is by far the most popular NPM package for creating HTTP APIs in node.js and has been around almost as long as the language itself. Start by creating a new directory called =hello-express= and initialize it using ~npm init~ (also don't forget to update =package.json= if you want to use JavaScript modules). Now let's install Express:

#+begin_src shell
  npm install express
#+end_src

Now let's create our first API by creating a new file called ~index.js~ in the project root directory and write the following code:

#+name: Our first API
#+begin_src js
  import express from 'express';

  const app = express();

  app.get('/hello', (req, res) => {
    res.send('Hello there!').end();
  });

  const PORT = 8080;

  app.listen(PORT, () => {
    console.log(`Server running at http://localhost:${PORT}`)
  });
#+end_src

There is /a lot/ to unpack here...
- We begin by creating an instance of an Express app.
- Then we /register/ a handler on the =/hello= endpoint which will respond with /Hello there!/.
- Lastly we start a server listening on /port/ 8080.

** Starting our server
Run your program by executing ~node index.js~. The first thing you will notice is that your program never quits: you see the message =Server running at http://localhost:8080= but you don't get a new prompt. This is because your program is running a *server* which is meant to serve *responses* to *requests* from *clients* and your program needs to be kept alive and running to be able to do that.

A client is whatever uses, or /consumes/, the API served by your server and can be anything from a web browser, website, another server or a command-line tool etc. For now, let's use our browser as the client and access the URL printed out by the program: [[http://localhost:8080]]. You should see an error message saying something like =Cannot GET /=.

#+caption: Accessing an unregistered endpoint results in an error message
#+name: not-found
[[./assets/cannot-get-slash.png]]

This means that we tried to =GET= something at the endpoint =/=. We'll get more into what =GET= actually means later when we talk about HTTP, but for now let's try changing the endpoint and go to [[http://localhost:8080/hello]] instead. Now you should instead see the expected message =Hello there!=.

#+caption: Successful call to our /hello endpoint
#+name: hello-there
[[./assets/hello-express-endpoint.png]]

So what went wrong the first time? There are four pieces of information needed to interact with a server:

- The *protocol* the server expects (=http=)
- The *machine* the server is running on (our machine =localhost= or =127.0.0.1= if we use its IP address). This is also called the *host*.
- The *port* the server is listening on (=8080=)
- The *endpoint* we want to consume (=/hello=)

A server only responds on the port it is listening on and only handles requests on endpoints which have been registered on it. When not specifying an endpoint, the browser will pick the default one which is =/= and since we never registered a handler for that endpoint the request failed. You can think of endpoints as file paths on your own computer.

** Adding another endpoint

#+name: Our next endpoint
#+begin_src js
  // ...

  app.get('/another-page', (req, res) => {
    res.send('Another page!').end();
  });

  // ...
#+end_src

If we add another endpoint and try to access it in the browser: [[http://localhost:8080/another-page]] we get the same error message as we did before.

The reason is that the server process is already running and changes made to the code will not be reflected until it is restarted. You can stop the server by selecting the terminal where it is running and press Ctrl-c (that means pressing the Ctrl button and the =c= key at the same time). This will terminate your server and get you back to the terminal prompt.

If you now run ~node index.js~ again you will be able to access [[http://localhost:8080/another-page]].

*** Live-reload and other tooling
A workflow like the above is not only annoying but it can also lead to long troubleshooting sessions trying to figure out why something isn't working, when in the end you just had to restart the server. Thankfully there is an NPM package which helps us automate this workflow: [[https://nodemon.io/][nodemon]]. Since we only need it for development we install it as a development dependency:

#+begin_src shell
  npm install --save-dev nodemon
#+end_src

Now we add a convenience script called ~dev~ in =package.json= to make it easy to use it:

#+begin_src json
  {
    // ...
    "scripts": {
      "dev": "nodemon index.js",
      "test": "echo \"Error: no test specified\" && exit 1"
    }
    // ...
  }
#+end_src

By running ~npm run dev~ your server will be started up and =nodemon= will watch your files for changes and restart the server when necessary.

There is another tool I highly recommend you install and that is [[https://prettier.io/][prettier]]. This tool formats your code automatically and you should be able to make your editor run it every time you save. Here is a [[https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode][VSCode plugin]] and here is one for [[https://github.com/prettier/prettier-emacs][Emacs]].

** Back to our endpoint
Let's make our new endpoint do something more interesting: let's see what happens if we serve a string which looks like HTML.

#+caption: Serving an HTML string
#+name: web-page-as-string
#+begin_src js
  // ...

  app.get("/another-page", (req, res) => {
    res
      .send(
        `
  <html>
  <head>
    <style>
    body {
      margin: 32px;
      background: hotpink;
      color: darkgreen;
      font-family: arial;
    }
    </style>
  </head>
  <body>
    <h1>Our beautiful page</h1>
    <marquee>We're serving a string which is rendered as a web page!</marquee>
  </body>
  </html>
  `
      )
      .end();
  });

  // ...
#+end_src

And we can see that our browser interprets it as HTML! The secret is that the browser interprets EVERYTHING as HTML, so we shouldn't be surprised.

While it's pretty cool that we can serve web pages as plain strings, what you usually want to do is to serve HTML files instead. We move our HTML to a file which we can call =beautiful-page.html=.

#+caption: Our beautiful HTML markup in a file of its own
#+name: beautiful-page.html
#+begin_src html
  <html>
  <head>
    <style>
    body {
      margin: 32px;
      background: hotpink;
      color: darkgreen;
      font-family: arial;
    }
    </style>
  </head>
  <body>
    <h1>Our beautiful page</h1>
    <marquee>We're serving a string which is rendered as a web page!</marquee>
  </body>
  </html>
#+end_src

And we change our handler to read that file and serve its contents.

#+caption: Serving HTML from a file
#+name: serving-page-from-file
#+begin_src js
  import express from "express";
  import fs from "fs";

  // ...

  app.get("/another-page", (req, res) => {
    const contents = fs.readFileSync("beautiful-page.html").toString();

    res.send(contents).end();
  });

  // ...
#+end_src

The page should load like before but the code looks a lot nicer without the inline HTML.

A website made up from files like this is called a *static website*. This is how the whole web worked through-out the 90s and the beginning of the 00s until *Single Page Applications* (SPAs) became a thing. In this course we will assume you will write your website as a SPA (in React), so we won't be serving static pages. In addition, the above code is highly inefficient and is just for illustrative purposes. First we are reading the HTML file for every request even though the contents doesn't change, this will lead to a lot of file system access which impacts performance. Second, we send the page a single string all at once which also impacts performance. If you are interested in how to serve static web pages using Express you can have a look [[https://expressjs.com/en/starter/static-files.html][at this documentation]].

* Deeper into Databases
* JavaScript Deep-Dive
