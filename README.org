#+title: Data Interaction Course Materials
#+author: Jens Östlund

This course aims to give you an understanding of back-end development and in it you will learn how to build an HTTP server in node.js and integrating it with a MongoDB database. The course will focus a lot on JavaScript and give you an understanding for how the language works so you will be able to solve issues in your code more readily.

* Setting up your environment
In order to follow along with this course you will want to have the following installed:

- [[https://nodejs.org/en/][node.js]] v16 or higher
- nom
- An editor with proper JavaScript support (VSCode, Sublime, Vim, Emacs, ...)
- [[https://git-scm.com/book/en/v2/Getting-Started-Installing-Git][Git]]

You can check that you have all necessary command line tools by running the following commands in your terminal:

#+begin_src shell
  node --version
  npm --version
  git --version
#+end_src

* Introduction to node.js
In short, node.js is JavaScript for servers and is now one of the most prevalent programming languages in the world. How come it quickly got so popular?

- The same language across the stack (front-end and back-end)
- Simplify the transition to full-stack for front-end developers
- The asynchronous nature of JavaScript makes it great for easily building high performance HTTP servers

In summary: familiarity and performance

Node.JS was created 12 years ago by creating a system interface to Chrome’s [[https://en.wikipedia.org/wiki/V8_(JavaScript_engine)][V8 JavaScript engine]]. That means that Node.JS is running the same version of JavaScript as Chrome and other [[https://en.wikipedia.org/wiki/Chromium_(web_browser)][Chromium]]-based browsers such as Microsoft Edge, Brave etc. Which V8 version Node uses dictates what JavaScript features it supports. If you are curious you can check which exact version of V8 your node.js installation is using by running the following command in a terminal:

#+begin_src shell
  node -p process.versions.v8
#+end_src

** node.js vs the Browser
Moving JavaScript out of the browser and onto the server results in a few important differences:

+ There's no browser environment, that is you do not have access to the global ~window~ and ~document~ objects.
+ You instead have a global variable ~global~ which refers to the current runtime environment.
+ You have access to built-in modules for doing things like reading and writing files and networking etc.
+ You have support for two different module systems (/CommonJS/ and /JavaScript modules/).
+ You use NPM for managing third party dependencies.

** Hello Node
We are going to play around with node.js a bit. First create a new directory called ~hello-node~ and move into it. Now create a file called =index.js= and write the following piece of code:

#+name: Writing to the terminal
#+begin_src js
  console.log("Hello node! \(>0<)/")
#+end_src

Now you can run your program with the command ~node index.js~ and you should see =Hello node! \(>0<)/= printed to your terminal. We have run JavaScript outside of the browser and successfully printed text, hooray!

A quick aside: naming the main file JavaScript file =index.js= is a convention and has no special meaning to node.js itself apart from it being loaded by default when importing a directory. We will have a look at what this means later, for now you can think of it as being analogous to naming the main page of a website =index.html= to avoid having to specify the full file path in the URL (link).

*** Importing modules (CommonJS vs JavaScript modules)
We can use node.js to play around with files but for that we need to import the built-in file system module ~fs~.

#+name: Writing to files
#+begin_src js
  const fs = require("fs");

  // We write a string to the file text.txt synchronously
  fs.writeFileSync("test.txt", "Here's some text in a file!");

  // And read the contents of it (also here synchronously!)
  const contents = fs.readFileSync("test.txt").toString();

  console.log(`File contents: ${contents}`);
#+end_src

In the above example we are using the default CommonJS style imports (~require~). In the examples in this course we are mainly going to use JavaScript modules (~import~, ~export~). You are free to use whichever style you are most comfortable with. If you want to use the ~import~ syntax you need to edit =package.json= and set the ~type~ property to ~module~ as in the example below. You can generate a =package.json= file by running ~npm init~ in the terminal and just accept all of the suggested default settings.

#+name Add support for JavaScript modules by editing package.json
#+begin_src json
  {
    "name": "hello-node",
    "type": "module",
    ...
  }
#+end_src

Now you can use the ~import~ syntax instead:

#+begin_src js
  import fs from "fs"
#+end_src

*** TODO Creating your own module
